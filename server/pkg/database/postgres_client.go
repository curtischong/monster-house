package database

import (
	"../config"
	"fmt"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

const(
	duplicateKeyError =  "duplicate key value violates unique constraint \"tag_name_key\""
)

type PostgresClient struct{
	config config.DatabaseConfig
}

func NewPostgresClient(
	config *config.Config,
) *PostgresClient{
	return &PostgresClient{
		config: config.DatabaseConfig,
	}
}

func (client *PostgresClient) InsertPhoto(
	photoID uuid.UUID,
	photoName, extensionName string,
)(err error){
	db, err := client.getDBClient()
	if err != nil{
		return
	}
	tx := db.MustBegin()
	_ , err = tx.Exec("INSERT INTO photo (id, name, extension) VALUES ($1, $2, $3);",
		photoID, photoName, extensionName)
	if err != nil{
		return
	}
	err = tx.Commit()
	return
}

func (client *PostgresClient) InsertTagIfNotExist(
	tagName string,
)(tagID uuid.UUID,err error){
	db, err := client.getDBClient()
	if err != nil{
		return
	}

	// Query from https://stackoverflow.com/a/62205017/4647924
	query := `WITH e AS(
		INSERT INTO tag (id, "name")
	VALUES ($1, $2)
	ON CONFLICT DO NOTHING
	RETURNING id
	)
	SELECT * FROM e
	UNION
	SELECT id FROM tag WHERE name=$2;
	`

	tagID = uuid.New()

	tx := db.MustBegin()
	err = tx.QueryRow(query, tagID, tagName).Scan(&tagID)
	if err != nil{
		return
	}
	err = tx.Commit()
	return
}

func (client *PostgresClient) InsertPhotoTags(
	photoID uuid.UUID,
	tagIDs []uuid.UUID,
	isAutoGenerated bool,
)(err error){
	db, err := client.getDBClient()
	if err != nil{
		return
	}

	query := "INSERT INTO photo_tag (photo_id, tag_id, is_auto_generated) VALUES"
	params := []interface{}{}
	// Build the query to built insert all the IDs
	for i, tagID := range tagIDs{
		tagIdx:= i*3
		query += fmt.Sprintf("($%d,$%d,$%d),", tagIdx+1, tagIdx+2, tagIdx+3)
		params = append(params, photoID, tagID, isAutoGenerated)
	}
	query = query[:len(query)-1] // remove trailing ","

	tx := db.MustBegin()
	_ , err = tx.Exec(query, params...)
	if err != nil{
		return
	}
	err = tx.Commit()
	return
}

func (client *PostgresClient) getDBClient() (*sqlx.DB, error){
	dataSourceName := fmt.Sprintf("user=%s password=%s dbname=%s sslmode=disable",
		client.config.Username, client.config.Password, client.config.DBName)
	db, err := sqlx.Connect("postgres", dataSourceName)
	if err != nil{
		return nil, fmt.Errorf("cannot connect to database. err=%s", err)
	}
	return db, nil
}